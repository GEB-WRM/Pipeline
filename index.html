
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sales Pipeline - George E. Booth Co., LLC</title>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=Work+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --primary: #C53030; --primary-dark: #9B2C2C; --secondary: #2D3748;
            --success: #38A169; --bg: #F7FAFC; --surface: #FFFFFF;
            --text: #1A202C; --text-light: #4A5568; --border: #E2E8F0;
            --shadow: rgba(197, 48, 48, 0.12);
        }
        body { font-family: 'Work Sans', sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; }
        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white; padding: 2rem; box-shadow: 0 4px 24px var(--shadow);
        }
        .header-content { max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: start; gap: 2rem; }
        .header-left { flex: 1; }
        .header-right { text-align: right; }
        .header h1 { font-size: 2.25rem; font-weight: 700; margin-bottom: 0.5rem; }
        .header .subtitle { font-size: 1rem; opacity: 0.95; margin-bottom: 0.5rem; }
        .contact-info { font-size: 0.9rem; }
        .contact-info div { margin-bottom: 0.25rem; }
        .contact-info a { color: white; text-decoration: none; }
        .contact-info a:hover { text-decoration: underline; }
        
        .tabs { 
            max-width: 1400px; margin: 0 auto; display: flex; gap: 0.5rem; 
            background: white; padding: 1rem 2rem 0; box-shadow: 0 2px 4px var(--shadow);
        }
        .tab { 
            padding: 0.75rem 1.5rem; border: none; background: transparent; 
            cursor: pointer; font-family: 'IBM Plex Mono', monospace; 
            font-size: 0.9rem; font-weight: 600; text-transform: uppercase;
            border-bottom: 3px solid transparent; transition: all 0.3s;
        }
        .tab:hover { background: var(--bg); }
        .tab.active { border-bottom-color: var(--primary); color: var(--primary); }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .container { max-width: 100%; margin: 0; padding: 2rem; }
        
        #map { height: 500px; border-radius: 12px; box-shadow: 0 2px 8px var(--shadow); margin-bottom: 2rem; }
        
        .controls { 
            background: var(--surface); padding: 2rem; border-radius: 12px; 
            box-shadow: 0 2px 8px var(--shadow); border-top: 4px solid var(--primary); 
            margin-bottom: 2rem; 
        }
        
        .import-section {
            margin-bottom: 2rem;
        }
        
        .import-section h3 {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
            text-transform: uppercase;
            margin-bottom: 1rem;
            color: var(--text);
        }
        
        .file-input-wrapper {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .btn {
            padding: 0.875rem 1.75rem; border: none; border-radius: 8px;
            font-family: 'IBM Plex Mono', monospace; font-size: 0.9rem; font-weight: 600;
            text-transform: uppercase; cursor: pointer; box-shadow: 0 2px 8px var(--shadow);
            transition: all 0.3s ease;
        }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-dark); transform: translateY(-2px); }
        .btn-secondary { background: var(--secondary); color: white; }
        
        input[type="file"] {
            padding: 0.75rem; border: 2px solid var(--border); border-radius: 8px;
            font-family: 'Work Sans', sans-serif; font-size: 1rem; background: var(--bg);
        }
        
        .account-table-wrapper {
            background: var(--surface); border-radius: 12px; box-shadow: 0 2px 8px var(--shadow);
            border-top: 4px solid var(--primary);
            max-height: 600px;
            overflow: auto;
            position: relative;
            width: 100%;
        }
        
        table { 
            width: 100%; border-collapse: collapse; 
        }
        
        thead { background: var(--secondary); color: white; }
        thead th {
            padding: 1rem; text-align: left; font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem; text-transform: uppercase; font-weight: 600;
            position: sticky; top: 0; z-index: 10;
            background: var(--secondary);
        }
        
        /* Freeze first two columns (checkbox and account name) */
        thead th:nth-child(1),
        thead th:nth-child(2) {
            position: sticky;
            left: 0;
            z-index: 20;
            background: var(--secondary);
        }
        
        thead th:nth-child(2) {
            left: 60px; /* Width of checkbox column */
        }
        
        tbody td:nth-child(1),
        tbody td:nth-child(2) {
            position: sticky;
            background: inherit;
            z-index: 5;
        }
        
        tbody td:nth-child(1) {
            left: 0;
        }
        
        tbody td:nth-child(2) {
            left: 60px; /* Width of checkbox column */
        }
        
        tbody tr { border-bottom: 1px solid var(--border); transition: background 0.2s; }
        tbody tr:hover { background: var(--bg); }
        tbody tr:hover td:nth-child(1),
        tbody tr:hover td:nth-child(2) {
            background: var(--bg);
        }
        tbody td {
            padding: 1rem; font-size: 0.95rem;
        }
        
        tbody tr.highlighted { background-color: #FEF3C7 !important; }
        tbody tr.highlighted td:nth-child(1),
        tbody tr.highlighted td:nth-child(2) {
            background-color: #FEF3C7 !important;
        }
        tbody tr.status-keep { background-color: #D1FAE5 !important; }
        tbody tr.status-keep td:nth-child(1),
        tbody tr.status-keep td:nth-child(2) {
            background-color: #D1FAE5 !important;
        }
        tbody tr.status-notsure { background-color: #FEF3C7 !important; }
        tbody tr.status-notsure td:nth-child(1),
        tbody tr.status-notsure td:nth-child(2) {
            background-color: #FEF3C7 !important;
        }
        tbody tr.status-remove { background-color: #FEE2E2 !important; }
        tbody tr.status-remove td:nth-child(1),
        tbody tr.status-remove td:nth-child(2) {
            background-color: #FEE2E2 !important;
        }
        
        .editable-cell {
            min-width: 100px;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: transparent;
            text-align: right;
            font-family: 'Work Sans', sans-serif;
        }
        
        .editable-cell.filled {
            background: transparent;
        }
        
        .editable-cell:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(197, 48, 48, 0.1);
        }
        
        .number-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            justify-content: center;
        }
        
        .number-input-wrapper input {
            flex: 1;
            min-width: 80px;
        }
        
        /* Hide number input spinners */
        .editable-cell[type="number"]::-webkit-inner-spin-button,
        .editable-cell[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .editable-cell[type="number"] {
            -moz-appearance: textfield;
        }
        
        .arrow-btn {
            background: var(--border);
            border: none;
            padding: 0.4rem 0.6rem;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.75rem;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        
        .arrow-btn:hover {
            background: var(--primary);
            color: white;
        }
        
        .status-select {
            padding: 0.5rem;
            border: 2px solid var(--border);
            border-radius: 4px;
            font-family: 'Work Sans', sans-serif;
            font-size: 0.9rem;
            background: white;
        }
        
        .totals-row {
            background: var(--secondary) !important;
            color: white;
            font-weight: 700;
        }
        
        .totals-row td {
            padding: 1rem;
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .review-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .leaflet-popup-content {
            font-family: 'Work Sans', sans-serif;
        }
        
        .popup-content h4 {
            margin-bottom: 0.5rem;
            color: var(--primary);
        }
        
        .popup-content p {
            margin: 0.25rem 0;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="header-left">
                <h1>Sales Pipeline</h1>
                <div class="subtitle">George E. Booth Co., LLC</div>
            </div>
            <div class="header-right">
                <div class="contact-info">
                    <div>Will McGowen</div>
                    <div><a href="mailto:wmcgowen@gebooth.com">wmcgowen@gebooth.com</a></div>
                    <div><a href="tel:6306551155">630-655-1155</a></div>
                </div>
            </div>
        </div>
    </div>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('account-map')">Account Map</button>
        <button class="tab" onclick="switchTab('strategy-2026')">2026 Strategy</button>
    </div>

    <div id="account-map" class="tab-content active">
        <div class="container">
            <div id="map"></div>
            
            <div class="controls">
                <div class="import-section">
                    <h3>Import Account Data</h3>
                    <p style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 1rem;">
                        <strong>Note:</strong> Accounts will be automatically plotted on the map using their City and State. 
                        The geocoding may take a few moments to complete.
                    </p>
                    <div class="file-input-wrapper">
                        <input type="file" id="accountFileInput" accept=".xlsx,.xls,.csv" />
                        <button class="btn btn-primary" onclick="importAccountData()">Import Accounts</button>
                        <button class="btn btn-secondary" onclick="exportAccountMap()">Export to Excel</button>
                    </div>
                </div>
            </div>
            
            <div class="account-table-wrapper">
                <table id="accountTable">
                    <thead>
                        <tr>
                            <th>Account Name</th>
                            <th>City</th>
                            <th>State</th>
                            <th>Customer ID</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="accountTableBody">
                        <!-- Account data will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="strategy-2026" class="tab-content">
        <div class="container">
            <div class="account-table-wrapper">
                <table id="strategyTable">
                    <thead>
                        <tr>
                            <th>Reviewed</th>
                            <th>Account Name</th>
                            <th>2024 Actual Net Sales</th>
                            <th>2025 Actual Net Sales</th>
                            <th>2026 Target</th>
                            <th>E+H Component</th>
                            <th>Filtration</th>
                            <th>Misc</th>
                            <th>Fittings</th>
                            <th>Samson</th>
                            <th>Valves</th>
                            <th>Projects</th>
                        </tr>
                    </thead>
                    <tbody id="strategyTableBody">
                        <!-- Strategy data will be populated here -->
                    </tbody>
                    <tfoot>
                        <tr class="totals-row">
                            <td></td>
                            <td>TOTALS</td>
                            <td id="total2024">$0.00</td>
                            <td id="total2025">$0.00</td>
                            <td id="total2026Target">$0.00</td>
                            <td id="totalEH">$0.00</td>
                            <td id="totalFiltration">$0.00</td>
                            <td id="totalMisc">$0.00</td>
                            <td id="totalFittings">$0.00</td>
                            <td id="totalSamson">$0.00</td>
                            <td id="totalValves">$0.00</td>
                            <td id="totalProjects">$0.00</td>
                        </tr>
                    </tfoot>
                </table>
            </div>
            
            <div class="controls" style="margin-top: 2rem;">
                <div class="import-section">
                    <h3>Import 2025 Data</h3>
                    <div class="file-input-wrapper">
                        <input type="file" id="strategyFileInput" accept=".xlsx,.xls,.csv" />
                        <button class="btn btn-primary" onclick="importStrategyData()">Import Strategy Data</button>
                        <button class="btn btn-secondary" onclick="exportStrategyData()">Export to Excel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global data storage
        let accountsData = [];
        let strategyData = [];
        let map;
        let markers = [];

        // Initialize map
        function initMap() {
            map = L.map('map').setView([41.8781, -87.6298], 6); // Centered on Illinois
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
        }

        // Geocode city and state to get coordinates
        let geocodeQueue = [];
        let geocodeIndex = 0;
        let isGeocoding = false;
        
        async function geocodeAndAddMarker(accountName, city, state, customerId) {
            try {
                // Use Nominatim (OpenStreetMap) geocoding service
                const query = encodeURIComponent(`${city}, ${state}, USA`);
                const url = `https://nominatim.openstreetmap.org/search?q=${query}&format=json&limit=1`;
                
                console.log(`Geocoding: ${accountName} - ${city}, ${state}`);
                
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'SalesPipeline/1.0'
                    }
                });
                
                if (!response.ok) {
                    console.error(`Geocoding failed for ${city}, ${state}: ${response.status}`);
                    return;
                }
                
                const data = await response.json();
                
                if (data && data.length > 0) {
                    const lat = parseFloat(data[0].lat);
                    const lng = parseFloat(data[0].lon);
                    
                    console.log(`✓ Geocoded ${accountName}: ${lat}, ${lng}`);
                    
                    const marker = L.marker([lat, lng]).addTo(map);
                    marker.bindPopup(`
                        <div class="popup-content">
                            <h4>${accountName}</h4>
                            <p><strong>City:</strong> ${city}</p>
                            <p><strong>State:</strong> ${state}</p>
                            <p><strong>Customer ID:</strong> ${customerId}</p>
                        </div>
                    `);
                    markers.push(marker);
                } else {
                    console.warn(`No geocoding results for ${city}, ${state}`);
                }
            } catch (error) {
                console.error(`Failed to geocode ${city}, ${state}:`, error);
            }
        }
        
        // Process geocoding queue with rate limiting
        async function processGeocodeQueue() {
            if (isGeocoding || geocodeQueue.length === 0) return;
            
            isGeocoding = true;
            
            while (geocodeQueue.length > 0) {
                const item = geocodeQueue.shift();
                await geocodeAndAddMarker(item.accountName, item.city, item.state, item.customerId);
                
                // Wait 1 second between requests to respect rate limits (Nominatim requires 1 req/sec)
                if (geocodeQueue.length > 0) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
            isGeocoding = false;
            
            // Fit map to all markers
            if (markers.length > 0) {
                setTimeout(() => {
                    const group = new L.featureGroup(markers);
                    map.fitBounds(group.getBounds().pad(0.1));
                }, 500);
            }
        }

        // Tab switching
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
            
            // Refresh map if switching to account map
            if (tabName === 'account-map' && map) {
                setTimeout(() => map.invalidateSize(), 100);
            }
        }

        // Import account data
        function importAccountData() {
            const fileInput = document.getElementById('accountFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file first');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                
                processAccountData(jsonData);
            };
            reader.readAsArrayBuffer(file);
        }

        // Process and display account data
        function processAccountData(data) {
            accountsData = data;
            
            // Clear existing markers
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            geocodeQueue = [];
            
            // Clear table
            const tbody = document.getElementById('accountTableBody');
            tbody.innerHTML = '';
            
            // Sort accounts alphabetically
            const sortedData = [...data].sort((a, b) => {
                const nameA = (a['Name'] || a['Account Name'] || a['AccountName'] || '').toString().toUpperCase();
                const nameB = (b['Name'] || b['Account Name'] || b['AccountName'] || '').toString().toUpperCase();
                return nameA.localeCompare(nameB);
            });
            
            console.log(`Processing ${sortedData.length} accounts`);
            
            // Process each account
            sortedData.forEach(account => {
                const accountName = account['Name'] || account['Account Name'] || account['AccountName'] || '';
                const city = account['Mail City'] || account['City'] || '';
                const state = account['Mail State'] || account['State'] || '';
                const customerId = account['Customer Id'] || account['Customer ID'] || account['CustomerID'] || '';
                const lat = parseFloat(account['Latitude'] || account['Lat'] || 0);
                const lng = parseFloat(account['Longitude'] || account['Lng'] || account['Long'] || 0);
                
                // Add to table
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${accountName}</td>
                    <td>${city}</td>
                    <td>${state}</td>
                    <td>${customerId}</td>
                    <td>
                        <select class="status-select" onchange="updateAccountStatus(${sortedData.indexOf(account)}, this.value)">
                            <option value="">-</option>
                            <option value="keep">Keep</option>
                            <option value="notsure">Not Sure</option>
                            <option value="remove">Remove</option>
                        </select>
                    </td>
                `;
                
                // Add to geocoding queue or use existing coordinates
                if (lat && lng && lat !== 0 && lng !== 0) {
                    // Use existing coordinates if available
                    const marker = L.marker([lat, lng]).addTo(map);
                    marker.bindPopup(`
                        <div class="popup-content">
                            <h4>${accountName}</h4>
                            <p><strong>City:</strong> ${city}</p>
                            <p><strong>State:</strong> ${state}</p>
                            <p><strong>Customer ID:</strong> ${customerId}</p>
                        </div>
                    `);
                    markers.push(marker);
                } else if (city && state) {
                    // Add to geocoding queue
                    geocodeQueue.push({
                        accountName: accountName,
                        city: city,
                        state: state,
                        customerId: customerId
                    });
                }
            });
            
            console.log(`Added ${geocodeQueue.length} accounts to geocoding queue`);
            
            // Start geocoding
            if (geocodeQueue.length > 0) {
                alert(`Geocoding ${geocodeQueue.length} account locations. This will take about ${Math.ceil(geocodeQueue.length)} seconds...`);
                processGeocodeQueue();
            } else if (markers.length > 0) {
                // Fit map to existing markers
                const group = new L.featureGroup(markers);
                map.fitBounds(group.getBounds().pad(0.1));
            }
            
            // Check for account mismatches
            checkAccountMatches();
        }

        // Import strategy data
        function importStrategyData() {
            const fileInput = document.getElementById('strategyFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file first');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array', cellDates: true, cellNF: false, cellText: false});
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                
                // Convert to JSON with defval to handle merged cells properly
                const jsonData = XLSX.utils.sheet_to_json(firstSheet, {
                    header: 1,
                    defval: null,
                    raw: false
                });
                
                console.log('Raw Excel data loaded, first 5 rows:', jsonData.slice(0, 5));
                processStrategyData(jsonData);
            };
            reader.readAsArrayBuffer(file);
        }

        // Process strategy data from Excel
        function processStrategyData(data) {
            console.log('Processing strategy data, total rows:', data.length);
            
            if (data.length < 2) {
                alert('File does not have enough rows');
                return;
            }
            
            // Find which row has "Account Name" header
            let headerRowIndex = -1;
            let accountNameIdx = -1;
            
            // Check first 3 rows for "Account Name" header
            for (let rowIdx = 0; rowIdx < Math.min(3, data.length); rowIdx++) {
                const row = data[rowIdx];
                for (let colIdx = 0; colIdx < row.length; colIdx++) {
                    const cell = row[colIdx];
                    if (cell && cell.toString().toLowerCase().trim() === 'account name') {
                        headerRowIndex = rowIdx;
                        accountNameIdx = colIdx;
                        console.log(`Found "Account Name" at Row ${rowIdx + 1}, Column ${colIdx + 1}`);
                        break;
                    }
                }
                if (headerRowIndex !== -1) break;
            }
            
            if (headerRowIndex === -1 || accountNameIdx === -1) {
                alert('Could not find "Account Name" header in the first 3 rows. Please check the file format.');
                console.error('First 3 rows:', data.slice(0, 3));
                return;
            }
            
            const headerRow = data[headerRowIndex];
            console.log('Header row (index ' + headerRowIndex + '):', headerRow);
            
            // Find other column indices from the header row
            let actual2024Idx = -1;
            let actual2025Idx = -1;
            
            for (let i = 0; i < headerRow.length; i++) {
                const header = headerRow[i];
                if (header) {
                    const headerStr = header.toString();
                    if (headerStr.includes('2023 Actual')) {
                        actual2024Idx = i;
                    } else if (headerStr.includes('2024 Actual')) {
                        actual2025Idx = i;
                    }
                }
            }
            
            console.log('2024 Actual index:', actual2024Idx);
            console.log('2025 Actual index:', actual2025Idx);
            
            // Find product category columns
            // They might be in the header row or in a row above it
            const columnMap = {
                'E+H': -1,
                'Filtration': -1,
                'Misc': -1,
                'Fittings': -1,
                'Samson': -1,
                'Valves': -1,
                'Projects': -1
            };
            
            // Check header row and row above (if exists) for product names
            const rowsToCheck = [headerRow];
            if (headerRowIndex > 0) {
                rowsToCheck.unshift(data[headerRowIndex - 1]); // Add row above
            }
            
            for (const rowToCheck of rowsToCheck) {
                for (let i = 0; i < rowToCheck.length; i++) {
                    const header = rowToCheck[i];
                    if (header) {
                        const headerStr = header.toString();
                        if ((headerStr.includes('Endress') || headerStr.includes('Hauser')) && columnMap['E+H'] === -1) {
                            columnMap['E+H'] = i;
                        } else if (headerStr.includes('Filtration') && columnMap['Filtration'] === -1) {
                            columnMap['Filtration'] = i;
                        } else if (headerStr.includes('Misc') && columnMap['Misc'] === -1) {
                            columnMap['Misc'] = i;
                        } else if (headerStr.includes('Fittings') && columnMap['Fittings'] === -1) {
                            columnMap['Fittings'] = i;
                        } else if (headerStr.includes('Samson') && columnMap['Samson'] === -1) {
                            columnMap['Samson'] = i;
                        } else if (headerStr.includes('Valves') && columnMap['Valves'] === -1) {
                            columnMap['Valves'] = i;
                        } else if (headerStr.includes('Projects') && columnMap['Projects'] === -1) {
                            columnMap['Projects'] = i;
                        }
                    }
                }
            }
            
            console.log('Product column map:', columnMap);
            
            const tbody = document.getElementById('strategyTableBody');
            tbody.innerHTML = '';
            strategyData = [];
            
            // Process data rows starting from the row after the header
            let rowsProcessed = 0;
            for (let i = headerRowIndex + 1; i < data.length; i++) {
                const row = data[i];
                if (!row || row.length === 0) continue;
                
                const accountName = row[accountNameIdx];
                if (!accountName) continue;
                
                const accountStr = accountName.toString().trim();
                if (accountStr === '') continue;
                
                // Skip section headers and totals
                const accountLower = accountStr.toLowerCase();
                if (accountLower.includes('total') || 
                    accountLower === 'end users' || 
                    accountLower === 'distributors' ||
                    accountLower.includes('sub-total')) {
                    console.log(`Skipping section header: ${accountStr}`);
                    continue;
                }
                
                // Parse numeric values
                const parseNum = (val) => {
                    if (!val) return 0;
                    const str = val.toString();
                    // Skip formulas
                    if (str.startsWith('=')) return 0;
                    const num = parseFloat(str);
                    return isNaN(num) ? 0 : num;
                };
                
                const rowData = {
                    accountName: accountStr,
                    actual2024: parseNum(row[actual2024Idx]),
                    actual2025: parseNum(row[actual2025Idx]),
                    target2026: 0,
                    eh: parseNum(row[columnMap['E+H']]),
                    filtration: parseNum(row[columnMap['Filtration']]),
                    misc: parseNum(row[columnMap['Misc']]),
                    fittings: parseNum(row[columnMap['Fittings']]),
                    samson: parseNum(row[columnMap['Samson']]),
                    valves: parseNum(row[columnMap['Valves']]),
                    projects: parseNum(row[columnMap['Projects']]),
                    reviewed: false
                };
                
                console.log(`Row ${i + 1} (${accountStr}):`, rowData);
                
                strategyData.push(rowData);
                addStrategyRow(rowData, strategyData.length - 1);
                rowsProcessed++;
            }
            
            console.log('Total rows processed:', rowsProcessed);
            alert(`Successfully imported ${rowsProcessed} accounts`);
            
            updateTotals();
            checkAccountMatches();
        }

        // Format currency
        function formatCurrency(value) {
            if (!value || value === 0) return '-';
            return '$' + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }
        
        // Update account status
        function updateAccountStatus(index, status) {
            const tbody = document.getElementById('accountTableBody');
            const row = tbody.rows[index];
            
            // Remove all status classes
            row.classList.remove('status-keep', 'status-notsure', 'status-remove');
            
            // Add appropriate class
            if (status === 'keep') {
                row.classList.add('status-keep');
            } else if (status === 'notsure') {
                row.classList.add('status-notsure');
            } else if (status === 'remove') {
                row.classList.add('status-remove');
            }
            
            // Store status in account data
            if (accountsData[index]) {
                accountsData[index].status = status;
            }
        }
        
        // Update product value and recalculate target
        function updateProductValue(index, field, value) {
            strategyData[index][field] = value;
            
            // Recalculate target2026 as sum of all product columns (excluding actual2025)
            const target = (strategyData[index].eh || 0) +
                          (strategyData[index].filtration || 0) +
                          (strategyData[index].misc || 0) +
                          (strategyData[index].fittings || 0) +
                          (strategyData[index].samson || 0) +
                          (strategyData[index].valves || 0) +
                          (strategyData[index].projects || 0);
            
            strategyData[index].target2026 = target;
            
            // Update the target cell display
            const targetCell = document.getElementById(`target-cell-${index}`);
            if (targetCell) {
                targetCell.textContent = formatCurrency(target);
            }
            
            updateTotals();
            
            // Update cell styling for the edited field
            const input = document.getElementById(`${field}-${index}`);
            if (input) {
                if (input.value && input.value !== '' && input.value !== '0') {
                    input.classList.add('filled');
                } else {
                    input.classList.remove('filled');
                }
            }
        }
        
        // Handle blur on dollar input fields to reformat
        function handleDollarInputBlur(index, field, inputElement) {
            const value = parseFloat(inputElement.value.replace(/[$,]/g, '')) || 0;
            strategyData[index][field] = value;
            
            // Reformat with dollar sign and commas
            if (value && value !== 0) {
                inputElement.value = '$' + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            } else {
                inputElement.value = '';
            }
        }
        
        // Adjust product value by $10,000
        function adjustProductValue(index, field, direction) {
            const currentValue = strategyData[index][field] || 0;
            let newValue;
            
            if (direction === 'up') {
                newValue = Math.ceil(currentValue / 10000) * 10000 + 10000;
            } else {
                newValue = Math.max(0, Math.floor(currentValue / 10000) * 10000 - 10000);
            }
            
            strategyData[index][field] = newValue;
            
            // Update the input field with formatted value
            const input = document.getElementById(`${field}-${index}`);
            if (input) {
                if (newValue && newValue !== 0) {
                    input.value = '$' + newValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                } else {
                    input.value = '';
                }
            }
            
            // Recalculate target (but not if the field being adjusted is actual2025)
            if (field !== 'actual2025') {
                updateProductValue(index, field, newValue);
            } else {
                updateTotals();
            }
        }

        // Format number for input display (shows with commas)
        function formatNumberInput(value) {
            if (!value || value === 0) return '';
            return value.toLocaleString('en-US');
        }
        
        // Parse formatted input back to number
        function parseFormattedInput(value) {
            if (!value) return 0;
            return parseFloat(value.toString().replace(/,/g, '')) || 0;
        }
        
        // Add a new row to strategy table
        function addStrategyRow(data = null, index = null) {
            const tbody = document.getElementById('strategyTableBody');
            const row = tbody.insertRow();
            const rowIndex = index !== null ? index : strategyData.length;
            
            if (data === null) {
                data = {
                    accountName: '',
                    actual2024: 0,
                    actual2025: 0,
                    target2026: 0,
                    eh: 0,
                    filtration: 0,
                    misc: 0,
                    fittings: 0,
                    samson: 0,
                    valves: 0,
                    projects: 0,
                    reviewed: false
                };
                strategyData.push(data);
            }
            
            const displayValue = (val) => val && val !== 0 ? '$' + val.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '';
            
            row.innerHTML = `
                <td><input type="checkbox" class="review-checkbox" onchange="toggleReviewed(${rowIndex})" ${data.reviewed ? 'checked' : ''}></td>
                <td><input type="text" class="editable-cell" value="${data.accountName}" onchange="updateStrategyData(${rowIndex}, 'accountName', this.value); checkAccountMatches();" style="text-align: left;"></td>
                <td>${formatCurrency(data.actual2024)}</td>
                <td>${formatCurrency(data.actual2025)}</td>
                <td id="target-cell-${rowIndex}">${formatCurrency(data.target2026)}</td>
                <td>
                    <div class="number-input-wrapper">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'eh', 'down')">▼</button>
                        <input type="text" class="editable-cell" id="eh-${rowIndex}" value="${displayValue(data.eh)}" 
                               onfocus="this.value = this.value.replace(/[$,]/g, '')" 
                               onblur="handleDollarInputBlur(${rowIndex}, 'eh', this)" 
                               onchange="updateProductValue(${rowIndex}, 'eh', parseFloat(this.value.replace(/[$,]/g, '')) || 0)">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'eh', 'up')">▲</button>
                    </div>
                </td>
                <td>
                    <div class="number-input-wrapper">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'filtration', 'down')">▼</button>
                        <input type="text" class="editable-cell" id="filtration-${rowIndex}" value="${displayValue(data.filtration)}" 
                               onfocus="this.value = this.value.replace(/[$,]/g, '')" 
                               onblur="handleDollarInputBlur(${rowIndex}, 'filtration', this)" 
                               onchange="updateProductValue(${rowIndex}, 'filtration', parseFloat(this.value.replace(/[$,]/g, '')) || 0)">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'filtration', 'up')">▲</button>
                    </div>
                </td>
                <td>
                    <div class="number-input-wrapper">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'misc', 'down')">▼</button>
                        <input type="text" class="editable-cell" id="misc-${rowIndex}" value="${displayValue(data.misc)}" 
                               onfocus="this.value = this.value.replace(/[$,]/g, '')" 
                               onblur="handleDollarInputBlur(${rowIndex}, 'misc', this)" 
                               onchange="updateProductValue(${rowIndex}, 'misc', parseFloat(this.value.replace(/[$,]/g, '')) || 0)">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'misc', 'up')">▲</button>
                    </div>
                </td>
                <td>
                    <div class="number-input-wrapper">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'fittings', 'down')">▼</button>
                        <input type="text" class="editable-cell" id="fittings-${rowIndex}" value="${displayValue(data.fittings)}" 
                               onfocus="this.value = this.value.replace(/[$,]/g, '')" 
                               onblur="handleDollarInputBlur(${rowIndex}, 'fittings', this)" 
                               onchange="updateProductValue(${rowIndex}, 'fittings', parseFloat(this.value.replace(/[$,]/g, '')) || 0)">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'fittings', 'up')">▲</button>
                    </div>
                </td>
                <td>
                    <div class="number-input-wrapper">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'samson', 'down')">▼</button>
                        <input type="text" class="editable-cell" id="samson-${rowIndex}" value="${displayValue(data.samson)}" 
                               onfocus="this.value = this.value.replace(/[$,]/g, '')" 
                               onblur="handleDollarInputBlur(${rowIndex}, 'samson', this)" 
                               onchange="updateProductValue(${rowIndex}, 'samson', parseFloat(this.value.replace(/[$,]/g, '')) || 0)">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'samson', 'up')">▲</button>
                    </div>
                </td>
                <td>
                    <div class="number-input-wrapper">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'valves', 'down')">▼</button>
                        <input type="text" class="editable-cell" id="valves-${rowIndex}" value="${displayValue(data.valves)}" 
                               onfocus="this.value = this.value.replace(/[$,]/g, '')" 
                               onblur="handleDollarInputBlur(${rowIndex}, 'valves', this)" 
                               onchange="updateProductValue(${rowIndex}, 'valves', parseFloat(this.value.replace(/[$,]/g, '')) || 0)">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'valves', 'up')">▲</button>
                    </div>
                </td>
                <td>
                    <div class="number-input-wrapper">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'projects', 'down')">▼</button>
                        <input type="text" class="editable-cell" id="projects-${rowIndex}" value="${displayValue(data.projects)}" 
                               onfocus="this.value = this.value.replace(/[$,]/g, '')" 
                               onblur="handleDollarInputBlur(${rowIndex}, 'projects', this)" 
                               onchange="updateProductValue(${rowIndex}, 'projects', parseFloat(this.value.replace(/[$,]/g, '')) || 0)">
                        <button class="arrow-btn" onclick="adjustProductValue(${rowIndex}, 'projects', 'up')">▲</button>
                    </div>
                </td>
            `;
            
            checkAccountMatch(rowIndex);
        }

        // Update strategy data
        function updateStrategyData(index, field, value) {
            strategyData[index][field] = value;
            updateTotals();
            checkAccountMatch(index);
        }

        // Toggle reviewed status
        function toggleReviewed(index) {
            strategyData[index].reviewed = !strategyData[index].reviewed;
            checkAccountMatch(index);
        }

        // Check if account exists in account map
        function checkAccountMatch(index) {
            const row = document.getElementById('strategyTableBody').rows[index];
            const accountName = strategyData[index].accountName.trim().toLowerCase();
            
            if (accountName === '') {
                row.classList.remove('highlighted');
                return;
            }
            
            const accountExists = accountsData.some(account => {
                const name = (account['Name'] || account['Account Name'] || account['AccountName'] || '').toString().trim().toLowerCase();
                return name === accountName;
            });
            
            // If account does NOT exist in Account Map and NOT reviewed, highlight yellow
            if (!accountExists && !strategyData[index].reviewed) {
                row.classList.add('highlighted');
            } else {
                row.classList.remove('highlighted');
            }
        }

        // Check all accounts
        function checkAccountMatches() {
            strategyData.forEach((data, index) => {
                checkAccountMatch(index);
            });
        }

        // Update totals
        function updateTotals() {
            const totals = {
                actual2024: 0,
                actual2025: 0,
                target2026: 0,
                eh: 0,
                filtration: 0,
                misc: 0,
                fittings: 0,
                samson: 0,
                valves: 0,
                projects: 0
            };
            
            strategyData.forEach(row => {
                totals.actual2024 += parseFloat(row.actual2024) || 0;
                totals.actual2025 += parseFloat(row.actual2025) || 0;
                totals.target2026 += parseFloat(row.target2026) || 0;
                totals.eh += parseFloat(row.eh) || 0;
                totals.filtration += parseFloat(row.filtration) || 0;
                totals.misc += parseFloat(row.misc) || 0;
                totals.fittings += parseFloat(row.fittings) || 0;
                totals.samson += parseFloat(row.samson) || 0;
                totals.valves += parseFloat(row.valves) || 0;
                totals.projects += parseFloat(row.projects) || 0;
            });
            
            document.getElementById('total2024').textContent = formatCurrency(totals.actual2024);
            document.getElementById('total2025').textContent = formatCurrency(totals.actual2025);
            document.getElementById('total2026Target').textContent = formatCurrency(totals.target2026);
            document.getElementById('totalEH').textContent = formatCurrency(totals.eh);
            document.getElementById('totalFiltration').textContent = formatCurrency(totals.filtration);
            document.getElementById('totalMisc').textContent = formatCurrency(totals.misc);
            document.getElementById('totalFittings').textContent = formatCurrency(totals.fittings);
            document.getElementById('totalSamson').textContent = formatCurrency(totals.samson);
            document.getElementById('totalValves').textContent = formatCurrency(totals.valves);
            document.getElementById('totalProjects').textContent = formatCurrency(totals.projects);
        }

        // Add new row button (you can add this if needed)
        function addNewRow() {
            addStrategyRow();
            updateTotals();
        }
        
        // Export Account Map to Excel
        function exportAccountMap() {
            if (accountsData.length === 0) {
                alert('No account data to export. Please import data first.');
                return;
            }
            
            const exportData = accountsData.map((account, index) => {
                return {
                    'Account Name': account['Name'] || account['Account Name'] || account['AccountName'] || '',
                    'City': account['Mail City'] || account['City'] || '',
                    'State': account['Mail State'] || account['State'] || '',
                    'Customer ID': account['Customer Id'] || account['Customer ID'] || account['CustomerID'] || '',
                    'Status': account.status || ''
                };
            });
            
            const ws = XLSX.utils.json_to_sheet(exportData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Account Map');
            
            const fileName = 'Account_Map_' + new Date().toISOString().split('T')[0] + '.xlsx';
            XLSX.writeFile(wb, fileName);
        }
        
        // Export Strategy Data to Excel
        function exportStrategyData() {
            if (strategyData.length === 0) {
                alert('No strategy data to export. Please import data first.');
                return;
            }
            
            const exportData = strategyData.map(row => {
                return {
                    'Account Name': row.accountName,
                    '2024 Actual Net Sales': row.actual2024 || 0,
                    '2025 Actual Net Sales': row.actual2025 || 0,
                    '2026 Target': row.target2026 || 0,
                    'E+H Component': row.eh || 0,
                    'Filtration': row.filtration || 0,
                    'Misc': row.misc || 0,
                    'Fittings': row.fittings || 0,
                    'Samson': row.samson || 0,
                    'Valves': row.valves || 0,
                    'Projects': row.projects || 0,
                    'Reviewed': row.reviewed ? 'Yes' : 'No'
                };
            });
            
            // Add totals row
            const totals = {
                'Account Name': 'TOTALS',
                '2024 Actual Net Sales': strategyData.reduce((sum, row) => sum + (parseFloat(row.actual2024) || 0), 0),
                '2025 Actual Net Sales': strategyData.reduce((sum, row) => sum + (parseFloat(row.actual2025) || 0), 0),
                '2026 Target': strategyData.reduce((sum, row) => sum + (parseFloat(row.target2026) || 0), 0),
                'E+H Component': strategyData.reduce((sum, row) => sum + (parseFloat(row.eh) || 0), 0),
                'Filtration': strategyData.reduce((sum, row) => sum + (parseFloat(row.filtration) || 0), 0),
                'Misc': strategyData.reduce((sum, row) => sum + (parseFloat(row.misc) || 0), 0),
                'Fittings': strategyData.reduce((sum, row) => sum + (parseFloat(row.fittings) || 0), 0),
                'Samson': strategyData.reduce((sum, row) => sum + (parseFloat(row.samson) || 0), 0),
                'Valves': strategyData.reduce((sum, row) => sum + (parseFloat(row.valves) || 0), 0),
                'Projects': strategyData.reduce((sum, row) => sum + (parseFloat(row.projects) || 0), 0),
                'Reviewed': ''
            };
            
            exportData.push(totals);
            
            const ws = XLSX.utils.json_to_sheet(exportData);
            
            // Format currency columns
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let R = range.s.r + 1; R <= range.e.r; R++) {
                for (let C = 1; C <= 10; C++) { // Columns B through K (numeric columns)
                    const cellAddress = XLSX.utils.encode_cell({r: R, c: C});
                    if (ws[cellAddress]) {
                        ws[cellAddress].z = '$#,##0.00';
                    }
                }
            }
            
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, '2026 Strategy');
            
            const fileName = '2026_Strategy_' + new Date().toISOString().split('T')[0] + '.xlsx';
            XLSX.writeFile(wb, fileName);
        }

        // Initialize on page load
        window.onload = function() {
            initMap();
        };
    </script>
</body>
</html>
